(require 'sotlisp)
(require 'my-utils)

(progn
  (setq sotlisp--default-function-abbrevs
    '(
      ("a" . "and ")
      ("ah" . "add-hook '")
      ("atl" . "add-to-list '")
      ("bb" . "bury-buffer")
      ("bc" . "forward-char -1")
      ("bfn" . "buffer-file-name")
      ("bl" . "buffer-list$")
      ("blp" . "buffer-live-p ")
      ("bn" . "buffer-name")
      ("bod" . "beginning-of-defun")
      ("bol" . "forward-line 0$")
      ;; ("bp" . "boundp '")
      ("bs" . "buffer-string$")
      ("bsn" . "buffer-substring-no-properties")
      ("bss" . "buffer-substring ")
      ("bw" . "forward-word -1")
      ("c" . "concat ")
      ("ca" . "char-after$")
      ("cb" . "current-buffer$")
      ("cc" . "condition-case er\n$\n(error nil)")
      ("ci" . "call-interactively ")
      ("cip" . "called-interactively-p 'any")
      ("csv" . "customize-save-variable '")
      ("d" . "delete-char 1")
      ("da" . "defalias '")               ; I still don't know why this does not work
      ("dc" . "delete-char 1")
      ("dcu" . "defcustom $ t\n  \"\"\n  :type 'boolean")
      ("df" . "defun $ ()\n  \"\"\n  ")
      ("dfa" . "defface $ \n  '((t))\n  \"\"\n  ")
      ("dfc" . "defcustom $ t\n  \"\"\n  :type 'boolean")
      ("dff" . "defface $ \n  '((t))\n  \"\"\n  ")
      ("dfv" . "defvar $ t\n  \"\"")
      ("dk" . "define-key ")
      ("dl" . "dolist (it $)")
      ("dt" . "dotimes (it $)")
      ("dmp" . "derived-mode-p '")
      ("dm" . "defmacro $ ()\n  \"\"\n  ")
      ("dr" . "delete-region ")
      ("dv" . "defvar $ t\n  \"\"")
      ("e" . "error \"$\"")
      ("ef" . "executable-find ")
      ("efn" . "expand-file-name ")
      ("eol" . "end-of-line")
      ("f" . "format \"$\"")
      ("fb" . "fboundp '")
      ("fbp" . "fboundp '")
      ("fc" . "forward-char 1")
      ("ff" . "find-file ")
      ("fl" . "forward-line 1")
      ("fp" . "functionp ")
      ("frp" . "file-readable-p ")
      ("fs" . "forward-sexp 1")
      ("fu" . "funcall ")
      ("fw" . "forward-word 1")
      ("g" . "goto-char ")
      ("gc" . "goto-char ")
      ("gsk" . "global-set-key ")
      ("i" . "insert ")
      ("ie" . "ignore-errors ")
      ("ii" . "interactive")
      ("il" . "if-let (($))")
      ("ir" . "indent-region ")
      ("jcl" . "justify-current-line ")
      ("jl" . "delete-indentation")
      ("jos" . "just-one-space")
      ("jr" . "json-read$")
      ("jtr" . "jump-to-register ")
      ("k" . ("kbd " (ask-for-binding)))
      ("kb" . "kill-buffer")
      ("kn" . "kill-new ")
      ("kp" . "keywordp ")
      ("l" . "lambda ($)")
      ("la" . ("looking-at \"" - "\""))
      ("lap" . "looking-at-p \"$\"")
      ("lb" . "looking-back \"$\"")
      ("lbp" . "line-beginning-position")
      ("lep" . "line-end-position")
      ("let" . "let (($))")
      ("lp" . "listp ")
      ("m" . "message \"$%s\"")
      ("mb" . "match-beginning 0")
      ("mc" . "mapcar ")
      ("mct" . "mapconcat ")
      ("me" . "match-end 0")
      ("ms" . "match-string 0")
      ("msn" . "match-string-no-properties 0")
      ("msnp" . "match-string-no-properties 0")
      ("msp" . "match-string-no-properties 0")
      ("mt" . "mapconcat ")
      ("n" . "not ")
      ("nai" . "newline-and-indent$")
      ("nl" . "forward-line 1")
      ("np" . "numberp ")
      ("ntr" . "narrow-to-region ")
      ("ow" . "other-window 1")
      ("p" . "point$")
      ("pm" . "point-marker$")
      ("pa" . "point-max$")
      ("pg" . "plist-get ")
      ("pi" . "point-min$")
      ("pz" . "propertize ")
      ("pv" . "provide ")
      ("r" . "require '")
      ("ra" . "use-region-p$")
      ("rap" . "use-region-p$")
      ("rb" . "region-beginning")
      ("re" . "region-end")
      ("rh" . "remove-hook '")
      ("rm" . "replace-match \"$\"")
      ("ro" . "regexp-opt ")
      ("rq" . "regexp-quote ")
      ("rris" . "replace-regexp-in-string ")
      ("rrs" . "replace-regexp-in-string ")
      ("rs" . "while (search-forward $ nil t)\n(replace-match \"\") nil t)")
      ("rsb" . "re-search-backward \"$\" nil 'noerror")
      ("rsf" . "re-search-forward \"$\" nil 'noerror")
      ("s" . "setq ")
      ("sb" . "search-backward $ nil 'noerror")
      ("sbr" . "search-backward-regexp $ nil 'noerror")
      ("scb" . "skip-chars-backward \"$\\r\\n[:blank:]\"")
      ("scf" . "skip-chars-forward \"$\\r\\n[:blank:]\"")
      ("se" . "save-excursion")
      ("sf" . "search-forward $ nil 'noerror")
      ("sfr" . "search-forward-regexp $ nil 'noerror")
      ("sic" . "self-insert-command")
      ("sl" . "setq-local ")
      ("sm" . "string-match \"$\"")
      ("smd" . "save-match-data")
      ("sn" . "symbol-name ")
      ("sp" . "stringp ")
      ("sq" . "string= ")
      ("sr" . "save-restriction")
      ("ss" . "substring ")
      ("ssn" . "substring-no-properties ")
      ("ssnp" . "substring-no-properties ")
      ("stb" . "switch-to-buffer ")
      ("sw" . "selected-window$")
      ("syp" . "symbolp ")
      ("tap" . "thing-at-point 'symbol")
      ("tf" . "thread-first ")
      ("tl" . "thread-last ")
      ("u" . "unless ")
      ("ul" . "up-list")
      ("up" . "unwind-protect\n(progn $)")
      ("urp" . "use-region-p$")
      ("w" . "when ")
      ("wcb" . "with-current-buffer ")
      ("wf" . "write-file ")
      ("wh" . "while ")
      ("wl" . "when-let (($))")
      ("we" . "window-end")
      ("ws" . "window-start")
      ("wsw" . "with-selected-window ")
      ("wtb" . "with-temp-buffer")
      ("wtf" . "with-temp-file ")))

  ;; Redefines the abbreviations

  (sotlisp-define-all-abbrevs))

(define-key sotlisp-mode-map (kbd "C-c v") nil)

;; vim +/"(defun sotlisp-turn-on-everywhere ()" "$EMACSD/manual-packages/speed-of-thought-lisp/sotlisp.el"
(remove-hook 'emacs-lisp-mode-hook #'sotlisp-mode)

(provide 'my-speed-of-thought)